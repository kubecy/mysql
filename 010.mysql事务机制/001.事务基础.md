# 事务基础

## 1.事务简介

>事务是指在数据库管理系统中，一系列操作被视为一个单独的、不可分割的工作单元。事务会把所有的操作作为一个整体一起向系
>
>统提交或撤销操作请求。这些操作要么全部成功执行，要么全部不执行，从而保证数据的一致性和完整性。

就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。

![image-20241019103405260](./000.picture/image-20241019103405260.png)

正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 。

异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。

为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。

![image-20241019103529610](./000.picture/image-20241019103529610.png)

>:bell:默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。

## 2.事务操作

1. 数据准备。

~~~sql
mysql> create  database  test_db;
Query OK, 1 row affected (0.00 sec)

mysql> use test_db;
Database changed
mysql> 
mysql> create table account(
    -> id int primary key AUTO_INCREMENT comment 'ID',
    -> name varchar(10) comment '姓名',
    -> money double(10,2) comment '余额'
    -> ) comment '账户表';
Query OK, 0 rows affected, 1 warning (0.03 sec)

mysql> 
mysql> insert into account(name, money) VALUES ('张三',2000), ('李四',2000);
~~~

### 2.1.未控制事务，

1. 测试正常数据。

~~~sql
-- 1. 查询张三余额
mysql> select * from account where name = '张三';
+----+--------+---------+
| id | name   | money   |
+----+--------+---------+
|  1 | 张三   | 2000.00 |
+----+--------+---------+
1 row in set (0.00 sec)

-- 2. 张三的余额减少1000
mysql> update account set money = money - 1000 where name = '张三';

-- 3. 李四的余额增加1000
mysql> update account set money = money + 1000 where name = '李四';

mysql> select * from account;
+----+--------+---------+
| id | name   | money   |
+----+--------+---------+
|  1 | 张三   | 1000.00 |
|  2 | 李四   | 3000.00 |
+----+--------+---------+
2 rows in set (0.00 sec)
~~~

2. 测试异常情况。

~~~sql
-- 1. 查询张三余额
select * from account where name = '张三';

-- 2. 张三的余额减少1000
update account set money = money - 1000 where name = '张三';
出错了....

-- 3. 李四的余额增加1000
update account set money = money + 1000 where name = '李四';
~~~

### 2.1.控制事务

1. 查看/设置事务提交方式

~~~sql
mysql> SELECT @@autocommit ;
+--------------+
| @@autocommit |
+--------------+
|            1 |
+--------------+
1 row in set (0.00 sec)

mysql> SET @@autocommit = 0 ;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @@autocommit ;
+--------------+
| @@autocommit |
+--------------+
|            0 |
+--------------+
1 row in set (0.00 sec)

mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)

mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
~~~

>:bell:上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。

~~~sql
START TRANSACTION 或 BEGIN ;

-- 1. 开启事务
mysql> BEGIN ;
Query OK, 0 rows affected (0.00 sec)

-- 2. 提交事务
mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)

-- 3. 回滚事务
mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
~~~

2. 案例

~~~sql
-- 开启事务
start transaction

-- 1. 查询张三余额
select * from account where name = '张三';

-- 2. 张三的余额减少1000
update account set money = money - 1000 where name = '张三';

-- 3. 李四的余额增加1000
update account set money = money + 1000 where name = '李四';

-- 如果正常执行完毕, 则提交事务
commit;

-- 如果执行过程中报错, 则回滚事务
-- rollback;
~~~

3. 事务自动提交方式设置方式优点缺点说明

| 序号   | 参数配置                           | 优势                                                         |
| ------ | ---------------------------------- | ------------------------------------------------------------ |
| 情况01 | autocommit=0 <br>关闭事务自动提交  | 可以编写多个关联的DML，进行一次性提交操作，若出现异常可以回滚<br>符合原子特性 |
|        |                                    | **劣势**                                                     |
|        |                                    | 可能出现多个关联的DML，只是完成了部分操作，这时就可能等待状态<br>基于隔离特性，操作的数据表或数据行就会进入锁定状态 |
|        | **参数配置**                       | **优势**                                                     |
| 情况02 | autocommit=1 <br/>开启事务自动提交 | 可以出现多个关联的DML，逐行操作自动提交，就可以不用处于锁等待状态 |
|        |                                    | **劣势**                                                     |
|        |                                    | 可能出现多个关联的DML，，每执行一条就进行提交，会造成多个语句执行不符合原子性 |

4. 在出现隐式自动提交时，可能导致提交的非事务语句有：

| 序号 | 语句类型     | 涉及命令                                            |
| ---- | ------------ | --------------------------------------------------- |
| 01   | DDL语句类型  | alter、create、drop                                 |
| 02   | DCL语句类型  | grant、revoke、set password                         |
| 03   | 锁定语句类型 | lock tables、unlock tables                          |
| 04   | 其他语句类型 | truncate table、load data infile、select for update |

## 3.事务四大特性（ACID）

1. **原子性（Atomicity）**：表示一个事务生命周期中的DML语句，要么全成功要么全失败，不可以出现中间状态。语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；**实现主要基于undo log**。
   - 事务在执行过程中，如果发生错误或被其他因素打断，则已经执行的操作会被回滚（Rollback），撤销到事务开始前的状态，就像这个事务从来没有执行过一样。这保证了数据库的一致性不会因为部分执行的操作而受到影响。
2. **一致性（Consistency）**：表示一个事务发生前、中、后，数据都最终保持一致，即事务执行的结果必须使数据库从一个一致性状态转变到另一个一致性状态。事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。
   - 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。例如，在转账过程中，从A账户转账到B账户，必须保证A账户减少的金额与B账户增加的金额相等，否则事务将不被提交，以保持数据库的一致性。
3. **隔离性（Isolation）**：在并发环境中，并发的事务是互相隔离的，一个事务的执行不能被其他事务干扰。 即使多个事务同时执行，每个事务也应该认为它是唯一在执行的事务，通常通过锁机制来实现。  
   - 不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间。一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。SQL标准定义了多个事务隔离级别，包括读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable），这些级别提供了不同程度的事务隔离。
4. **持久性（Durability）**：一旦事务成功提交，其对数据库的改变是永久性的，即使系统崩溃或出现故障，这些变化也不会丢失。事务的结果被保存在持久存储中，确保数据的持久性。  即可永久生效（落盘），保证事务提交后不会因为宕机等原因导致数据丢失；**实现主要基于redo log**。
   - 在事务进行过程中，未结束之前，数据修改只是在内存中进行的，不会影响到物理数据库。只有当事务成功提交后，数据修改才会被写入硬盘上的数据库中，并且这些修改是永久性的，不会因为系统故障而丢失。

